/*
 * Copyright Â© 2011,2015 Liquid Robotics
 * Licensed under Apache 2.0 https://github.com/JamesGosling/DayNightTerminator/blob/master/LICENSE
 * Created by James Gosling, based on the following matlab code:
 * 
 * 
 * %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 * % Copyright (c) 2009-2012, Centre for Advanced Internet Architectures
 * % Swinburne University of Technology, Melbourne, Australia
 * % (CRICOS number 00111D).
 * %
 * %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 * %
 * % plotdaynightterminator.m
 * % A script for Matlab to draw the Day-Night terminator and the night shadow upon
 * % a map created with the following two commands of the Mapping Toolbox:
 * %
 * % load coast;
 * % mapshow(long,lat,'Color','black');
 * %
 * % The function will calculate the day-night terminator based on the GMT (UTC) date.
 * % It will draw the terminator which fits the map created using the mapshow command,
 * % and fill the night part of the map with a dark gray colour.
 * % The effect is similar to http://www.timeanddate.com/worldclock/sunearth.html and
 * % http://www.daylightmap.com/index.php
 * %
 * % The script needs the equinox information for the years it applies.
 * % Currently only the 2009 and 2010 equinox information are included.
 * % more equinox information can be found at:
 * % http://www.timeanddate.com/calendar/seasons.html
 * % (don't forget to switch to GMT at the bottom of the page)
 * %
 * % This script has been generated by following hints, tips and scripts found at:
 * % http://www.geoastro.de/elevaz/basics/index.htm
 * %
 * % This file is part of the animation_scripts.tar.gz tarball that can be obtained at:
 * % http://caia.swin.edu.au/sting/tools/
 * %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 * %
 * % This software was developed by Mattia Rossi <mrossi@swin.edu.au>
 * %
 * % This software has been made possible in part by a grant from
 * % APNIC Pty. Ltd., Canberra, Australia. http://www.apnic.net/
 * %
 * % All rights reserved.
 * %
 * % Redistribution and use in source and binary forms, with or without
 * % modification, are permitted provided that the following conditions
 * % are met:
 * % 1. Redistributions of source code must retain the above copyright
 * %    notice, this list of conditions and the following disclaimer.
 * % 2. Redistributions in binary form must reproduce the above copyright
 * %    notice, this list of conditions and the following disclaimer in the
 * %    documentation and/or other materials provided with the distribution.
 * % 3. The names of the authors, the "Centre for Advanced Internet Architecture"
 * %    and "Swinburne University of Technology" may not be used to endorse
 * %    or promote products derived from this software without specific
 * %    prior written permission.
 * %
 * % THIS SOFTWARE IS PROVIDED BY THE AUTHORS AND CONTRIBUTORS "AS IS" AND
 * % ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * % IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * % ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE
 * % FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * % DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * % OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * % HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * % LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * % OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * % SUCH DAMAGE.
 */
package com.nighthacks.fx.daynightterminator;

import static java.lang.Math.*;
import java.util.*;
import javafx.collections.*;
import javafx.scene.image.*;
import javafx.scene.layout.*;
import javafx.scene.shape.*;
import javafx.scene.transform.*;

public class DayNightTerminator extends AnchorPane {
    public static DayNightTerminator colorful() {
        return new DayNightTerminator(
                DayNightTerminator.class.getResource("night.png").toString(), 
                DayNightTerminator.class.getResource("day.jpg").toString());
    }
    public static DayNightTerminator greyscale() {
        return new DayNightTerminator(
                DayNightTerminator.class.getResource("nightGrey.png").toString(), 
                DayNightTerminator.class.getResource("dayGrey.png").toString());
    }
    //DayNightTerminator.class.getResource("night.jpg").toString()
    // DayNightTerminator.class.getResource("day.jpg").toString()
    public DayNightTerminator(String dayImageURL, String nightImageURL) {
        dayImage = new ImageView(dayImageURL);
        nightImage = new ImageView(nightImageURL);
        init(System.currentTimeMillis());
    }
    private void init(long t) { // to avoid complains about overridable methods
        widthProperty().addListener((n) -> setTransform());
        heightProperty().addListener((n) -> setTransform());
        setMaxSize(Double.MAX_VALUE, Double.MAX_VALUE);
        setPrefSize(360, 180);
        dayImage.setPreserveRatio(false);
        dayImage.setSmooth(true);
        dayImage.setCache(true);
        dayImage.fitWidthProperty().set(360);
        dayImage.fitHeightProperty().set(180);
        nightImage.setPreserveRatio(false);
        nightImage.setSmooth(true);
        nightImage.setCache(true);
        nightImage.fitWidthProperty().set(360);
        nightImage.fitHeightProperty().set(180);
//        nightImage.setOpacity(1);
        getChildren().add(dayImage);
        getChildren().add(nightImage);
        setTime(t);
    }
    public final void setTime(long t) {
        if (abs(t - displayedTime) < 2 * 60 * 1000)
            return; // Don't bother with small changes
        double[] c0 = DayNightTerminator.computeDayNightTerminator(t);
        int len = c0.length;
        double[] c1 = new double[len * 2 + 4];
        int pos = 0;
        for (int i = 0; i < len; i++) {
            c1[pos++] = (double) i;
            c1[pos++] = c0[i];
        }
        final double inyear = yearfraction(t);
        double y = inyear >= vernalEquinox && inyear <= autumnalEquinox
                   ? 180
                   : 0;
        c1[pos++] = len - 1.;
        c1[pos++] = y;
        c1[pos++] = 0.;
        c1[pos++] = y;
        nightImage.setClip(new Polygon(c1));
        displayedTime = t;
    }

    private static double[] computeDayNightTerminator(long t) {
        final double jd2 = t / (double) (1000 * 60 * 60 * 24);
        final double juliandate = jd2 + 2440587.500000; //2440802.101097234;
        final double K = PI / 180;
        final double T = (juliandate - 2451545.0) / 36525;
        double L = 280.46645 + 36000.76983 * T + 0.0003032 * T * T;
        L = L % 360;
        if (L < 0)
            L = L + 360;
        double M = 357.52910 + 35999.05030 * T - 0.0001559 * T * T -
                0.00000048 * T * T * T;
        M = M % 360;
        if (M < 0)
            M = M + 360;
        final double C = (1.914600 - 0.004817 * T - 0.000014 * T * T) * sin(K * M) +
                 (0.019993 - 0.000101 * T) * sin(K * 2 * M) +
                 0.000290 * sin(K * 3 * M);
        final double theta = L + C;
        final double LS = L;
        final double LM = 218.3165 + 481267.8813 * T;
        final double eps0 = 23.0 + 26.0 / 60.0 + 21.448 / 3600.0 -
                (46.8150 * T +
                0.00059 * T * T - 0.001813 * T * T * T) / 3600;
        final double omega = 125.04452 - 1934.136261 * T + 0.0020708 * T * T +
                T * T *
                T / 450000;
        final double deltaEps =
                (9.20 * cos(K * omega) + 0.57 * cos(K * 2 * LS) +
                0.10 * cos(K * 2 * LM) - 0.09 * cos(K * 2 * omega)) / 3600;
        final double eps = eps0 + deltaEps + 0.00256 *
                cos(K * (125.04 - 1934.136 * T));
        final double lambda = theta - 0.00569 - 0.00478 * sin(K * (125.04 -
                1934.136 *
                T));
        final double delta = asin(sin(K * eps) * sin(K * lambda));
        final double dec = delta / K;
        final double tau = (juliandate - floor(juliandate)) * 360;
        double[] coords = new double[361];
        for (int i = 0; i < 361; i++)
            coords[i] = atan(cos((i - 180 + tau) * K) / tan(dec * K)) / K + 90;
        return coords;
    }
    private void setTransform() {
        ObservableList<Transform> xforms = getTransforms();
        if (prevTransform != null) xforms.remove(prevTransform);
        xforms.add(prevTransform = new Scale(
                widthProperty().doubleValue() / 360,
                heightProperty().doubleValue() / 180));
    }
    private static double yearfraction(long t) {
        double y = t / (365.2425 * 24 * 60 * 60 * 1000);  // fractional years since the epoch
        return y - floor(y);
    }
    private static final double vernalEquinox = yearfraction(Date
            .parse("March 20, 2016 04:30 UTC"));
    private static final double autumnalEquinox = yearfraction(Date
            .parse("September 22, 2016 14:21 UTC"));
    private Transform prevTransform = null;
    private long displayedTime = 0;
    private final ImageView nightImage, dayImage;
}
